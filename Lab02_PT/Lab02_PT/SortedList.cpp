#include "SortedList.h"

// Make list empty. (Initialize list)
void SortedList::MakeEmpty()
{
	m_Length = 0;
}


// Return the number of records in the list.
int SortedList::GetLength()
{
	return m_Length;
}


// Check the list upper is reached to the limit.
bool SortedList::IsFull()
{
	if (m_Length >= MAXSIZE) {
		return true;
	}
	return false;
}


// Check the list is empty.
bool SortedList::IsEmpty()
{
	if (m_Length == 0) {
		return true;
	}
	return false;
}


// Initialize the list iterator.
void SortedList::ResetList()
{
	m_CurPointer = -1;
}


// Update pointer to point to next record, and get that new record.
int SortedList::GetNextItem(ItemType& data)
{
	//---------------------------------------------------------------
	// (1) 현재 Pointer를 increment하여 다음 item의 index를 가리킨다.
	// (2) Pointer가 capacity를 넘어서면, 실패(-1)를 return.
	// (3) List에서 해당 index의 data를 가져온다.
	// (4) 현재 위치를 출력한다.
	// ---------------------------------------------------------------
	m_CurPointer++;												// (1).
	if (m_CurPointer == MAXSIZE) {								// (2).
		return -1;
	}
	data = m_Array[m_CurPointer];								// (3).
	return m_CurPointer;										// (4).
}


// Add a new data into list.
int SortedList::Add(ItemType data)
{
	//---------------------------------------------------------------
	// (1) 현재 list의 용량을 확인한다.
	//	   - 다 채워져있을 경우, 실패(0)을 return.
	//	   - 빈 경우, 첫 자리 삽입, 길이 증가, 성공(1) return.
	// (2) 삽입 위치를 찾기 위해, GetNextItem을 사용한다
	//	   - Position을 저장할 변수, 검색 확인하는 변수 found 선언.
	//	   - List에서 받아온 item을 저장할 변수 temp 선언.
	//	   - ResetList(), 포인터 초기화
	//	   - Position에 시작지점 저장, 끝에 도달하면 -1.
	// (3) 정렬리스트, 삽입을 위한 위치 파악하기.
	//	   - case EQUAL, 중복된 item이 존재하므로 실패(0) return.
	//	   - case GREATER, 리스트에 담긴 item이 더 크므로 존재x, 실패(0)
	//	   - case LESS, 다음 item을 받아온다.
	// (4) 삽입
	//	   - 검색이 되지 않은 경우, 맨 끝에다 삽입한다. 성공(1).
	//	   - 중간에 삽입된 경우, 후방 데이터를 이동하고 삽입. 성공(1).
	// ---------------------------------------------------------------

	if (IsFull()) { return 0; }									// (1).
	if (IsEmpty()) {
		m_Array[m_Length++] = data;
		return 1;
	}

	int Position = 0;											// (2).
	bool found = false;
	ItemType temp;
	ResetList();
	Position = GetNextItem(temp);

	while (Position > -1 && !found)								// (3).
	{
		switch (temp.Compare(data))
		{
		case EQUAL:
			cout << "\tError: duplicated item in the list\n";
			return 0;
		case GREATER:
			found = true;
			break;
		case LESS:
			Position = GetNextItem(temp);
			break;
		}
	}

	if (Position == -1) {										// (4).
		m_Array[m_Length++] = data;
		return 1;
	}

	for (int i = m_Length; i > Position; i--) {					// (5).
		m_Array[i] = m_Array[i - 1];
	}
	m_Array[Position] = data;
	m_Length++;
	return 1;
}


// Delete item in accordance with data's primary key.
int SortedList::Delete(ItemType data)
{
	//---------------------------------------------------------------
	// (1) List가 비어있는지 확인. 비어있을시 삭제 실패(0)을 return.
	// (2) List가 비어있지 않는 경우,
	//	   - List에서 data를 검색한다. 
	//	   [1] 성공(1) return시, 상위 data를 이동하고 길이를 줄인다.
	//	   [2] 실패(0) return.
	// ---------------------------------------------------------------
	if (IsEmpty()) { return 0; }								// (1).
	else {														// (2).
		if (Retrieve_SeqS(data)) {
			for (int i = m_CurPointer; i < m_Length; i++) {
				m_Array[i] = m_Array[i + 1];
			}
			m_Length--;
			return 1;
		}
		else { return 0; }
	}
}


// Find same record using primary key and replace it.
int SortedList::Replace(ItemType data)
{
	//---------------------------------------------------------------
	// (1) List가 비어있는지 확인. 비어있을시 삭제 실패(0)을 return.
	// (2) 검색 확인 변수 isFind, 포인터 초기화
	// (3) 검색, 교체
	//	   - List에서 data를 검색한다. 
	//	   [1] 찾게 되면, 성공(1) return.
	//	   [2] 실패(0) return.
	// ---------------------------------------------------------------
	if (IsEmpty()) { return 0; }								// (1).

	bool isFind = false;										// (2).
	ResetList();
	m_CurPointer++;

	for (m_CurPointer; m_CurPointer < m_Length; m_CurPointer++) {// (3).
		if (!isFind) {
			if (m_Array[m_CurPointer] == data) {
				m_Array[m_CurPointer] = data;
				isFind = true;
				break;
			}
		}
	}

	if (isFind) {
		return 1;
	}
	else {
		cout << "\tFail to find and replace item!" << '\n';
		return 0;
	}
}


// Find the item whose primary key matches with the primary 
int SortedList::Retrieve_SeqS(ItemType& data)
{
	//---------------------------------------------------------------
	// (1) List의 element를 받아올 ItemType CurItem 생성.
	// (2) List의 Current Pointer 초기화.
	// (3) List의 첫번째 item을 받아옴.
	// (4) 정렬 리스트, 검색 시작
	//	   - case LESS  의 경우, 다음 item을 받아온다.
	//	   - case EQUAL 의 경우, item을 반환하고, 1을 return한다.
	//	   - case GRETER의 경우, item이 없으므로, 0을 return한다.
	// (5) 함수가 실패하면, 0을 return한다.
	// ---------------------------------------------------------------
	ItemType CurItem;											// (1).
	ResetList();												// (2).
	GetNextItem(CurItem);										// (3).

	while (m_CurPointer < m_Length)								// (4).
	{
		switch (CurItem.Compare(data))
		{
		case EQUAL:
			data = CurItem;
			return 1;
			break;
		case GREATER:
			return 0;
			break;
		default:
			GetNextItem(CurItem);
			break;
		}
	}
	return 0;													// (5).
}



// Retrieve by using binary search.
int SortedList::RetrieveByBS(ItemType& data)
{
	//---------------------------------------------------------------
	// (1) List가 비어있으면, 실패(0)을 return한다.
	// (2) 시작점을 배열의 중간 지점으로 설정.
	// (3) 정렬 리스트, 2진 검색 시작.
	//	   - case LESS 의 경우
	//		 [1] 비교한 데이터가 리스트의 마지막이면, 실패(0)을 return.
	//		 [2] 아닌 경우, 해당 지점과 끝 지점의 사이로 Position 이동.
	//	   - case EQUAL 의 경우
	//		 [1] 해당 지점의 item을 반환하고, 성공(1)을 return.
	//	   - case GREATER 의 경우
	//		 [1] 비교한 데이터가 리스트의 첫 지점이면, 실패(0)을 return.
	//		 [2] 아닌 경우, 해당 지점과 첫 지점의 사이로 Position 이동.
	// (4) 함수가 실패하면, 실패(0)을 return.
	// ---------------------------------------------------------------
	if (IsEmpty()) { return 0; }								// (1).
	int curPosition = m_Length / 2;								// (2).
	while (1)													// (3).
	{
		switch (m_Array[curPosition].Compare(data))
		{
		case EQUAL:
			data = m_Array[curPosition];
			return 1;
			break;
		case GREATER:
			if (curPosition == 0)
				return 0;
			curPosition /= 2;
			break;
		case LESS:
			if (curPosition == m_Length - 1)
				return 0;
			curPosition = (curPosition + m_Length) / 2;
			break;
		}
	}
	return 0;													 // (4).

}

